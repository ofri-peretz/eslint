# yaml-language-server: $schema=https://json.schemastore.org/github-workflow.json
name: Release Package

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# UNIFIED RELEASE WORKFLOW
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# Single workflow to release packages in the monorepo.
# - Select a specific package OR
# - Select "all-affected" to release all packages with changes since last release
#
# Dependency Order: @interlace/eslint-devkit is ALWAYS released first when affected,
# since other packages depend on it.
#
# Trigger: Manual only (workflow_dispatch)
# Branch: main only
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# NPM AUTHENTICATION STRATEGY (2025+)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#
# PRIORITY 1: NPM Trusted Publishers (OIDC - Recommended for existing packages)
#   - Requires: id-token: write permission
#   - Requires: Package already exists on npm with Trusted Publisher configured
#   - Setup: npm.js.com â†’ Package Settings â†’ Publishing access â†’ Add GitHub Actions
#   - Uses GitHub OIDC to mint short-lived tokens (no secrets needed)
#   - Publishes with provenance attestation
#
# PRIORITY 2: NPM_TOKEN (Legacy - Required for first-release)
#   - Required for NEW packages that don't exist on npm yet
#   - After first publish, configure Trusted Publishers and remove token
#   - Uses Granular Access Token with minimal scopes
#
# FIRST RELEASE FLOW:
#   1. Workflow detects package doesn't exist on npm (404)
#   2. Uses NPM_TOKEN + --first-release flag for initial publish
#   3. After success, go to npmjs.com and configure Trusted Publishers
#   4. Future releases use OIDC (no token needed)
#
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

on:
  workflow_dispatch:
    inputs:
      package:
        description: "Package to release (all-affected = release all changed packages)"
        required: false
        type: choice
        default: "all-affected"
        options:
          - all-affected
          - eslint-devkit
          - eslint-plugin-secure-coding
          - eslint-plugin-import-next
          - eslint-plugin-express-security
          - eslint-plugin-nestjs-security
          - eslint-plugin-browser-security
          - eslint-plugin-crypto
          - eslint-plugin-jwt
          - eslint-plugin-pg
          - eslint-plugin-lambda-security
          - eslint-plugin-vercel-ai-security
          - eslint-plugin-architecture
          - eslint-plugin-quality
          - eslint-plugin-react-a11y
          - eslint-plugin-react-features
          - cli

      version-specifier:
        description: "Version bump strategy (auto = conventional commits)"
        required: false
        type: choice
        options:
          - auto
          - major
          - minor
          - patch
          - premajor
          - preminor
          - prepatch
          - prerelease
        default: "auto"

      dist-tag:
        description: "NPM distribution tag"
        required: false
        type: choice
        options:
          - latest
          - next
          - beta
          - rc
          - alpha
        default: "latest"

      run-ci:
        description: "Run CI validation (usually not needed - main already passed CI)"
        required: false
        type: boolean
        default: false

      dry-run:
        description: "Dry run: preview changes without modifying git or NPM"
        required: false
        type: boolean
        default: false

      force-version:
        description: "Force specific version (e.g., 3.1.0) - overrides version-specifier"
        required: false
        type: string
        default: ""

      generate-changelog:
        description: "Generate changelog (creates GitHub release)"
        required: false
        type: boolean
        default: true

# Prevent concurrent release runs
concurrency:
  group: release-workflow
  cancel-in-progress: false

env:
  NODE_VERSION: "24"
  PNPM_VERSION: "10.18.3"
  # Dependency order: devkit MUST be first since others depend on it
  # This array defines the release sequence for all-affected mode
  DEPENDENCY_ORDER: "eslint-devkit,eslint-plugin-secure-coding,eslint-plugin-crypto,eslint-plugin-jwt,eslint-plugin-pg,eslint-plugin-express-security,eslint-plugin-nestjs-security,eslint-plugin-browser-security,eslint-plugin-lambda-security,eslint-plugin-vercel-ai-security,eslint-plugin-architecture,eslint-plugin-quality,eslint-plugin-react-a11y,eslint-plugin-react-features,eslint-plugin-import-next,cli"

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STEP 1: DETECT AFFECTED PACKAGES
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  detect-affected:
    name: ğŸ” Detect Affected Packages
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.detect.outputs.packages }}
      package-count: ${{ steps.detect.outputs.package-count }}
      matrix: ${{ steps.detect.outputs.matrix }}
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          ref: main

      - name: âš™ï¸ Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: âš™ï¸ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "pnpm"

      - name: ğŸ“¦ Install dependencies
        run: pnpm install --frozen-lockfile

      - name: ğŸ§¹ Clean up orphaned tags
        id: cleanup-tags
        run: |
          echo "ğŸ§¹ Checking for orphaned tags (git tag exists but npm version doesn't)..."
          echo ""

          ORPHANED_TAGS=""
          CLEANED_COUNT=0

          # Check all publishable packages
          for pkg in eslint-devkit eslint-plugin-secure-coding eslint-plugin-crypto eslint-plugin-jwt eslint-plugin-pg eslint-plugin-express-security eslint-plugin-nestjs-security eslint-plugin-browser-security eslint-plugin-lambda-security eslint-plugin-vercel-ai-security eslint-plugin-architecture eslint-plugin-quality eslint-plugin-react-a11y eslint-plugin-react-features eslint-plugin-import-next cli; do
            # Resolve npm package name
            case "$pkg" in
              eslint-devkit) NPM_NAME="@interlace/eslint-devkit" ;;
              cli) NPM_NAME="@interlace/cli" ;;
              *) NPM_NAME="$pkg" ;;
            esac
            
            # Get local version from package.json
            LOCAL_VER=$(node -p "require('./packages/$pkg/package.json').version" 2>/dev/null || echo "")
            if [ -z "$LOCAL_VER" ]; then
              continue
            fi
            
            EXPECTED_TAG="${pkg}@${LOCAL_VER}"
            
            # Check if git tag exists
            if git rev-parse "$EXPECTED_TAG" >/dev/null 2>&1; then
              # Check if npm version exists
              NPM_VER=$(npm view "$NPM_NAME@$LOCAL_VER" version 2>/dev/null || echo "")
              
              if [ -z "$NPM_VER" ]; then
                echo "ğŸ—‘ï¸ ORPHANED TAG FOUND: $EXPECTED_TAG"
                echo "   â””â”€ Git tag exists but npm version $NPM_NAME@$LOCAL_VER does not exist"
                echo "   â””â”€ Deleting local and remote tag..."
                
                # Delete local tag
                git tag -d "$EXPECTED_TAG" 2>/dev/null || true
                
                # Delete remote tag
                git push origin ":refs/tags/$EXPECTED_TAG" 2>/dev/null || true
                
                echo "   âœ… Deleted orphaned tag: $EXPECTED_TAG"
                ORPHANED_TAGS="$ORPHANED_TAGS $EXPECTED_TAG"
                CLEANED_COUNT=$((CLEANED_COUNT + 1))
              fi
            fi
          done

          if [ $CLEANED_COUNT -gt 0 ]; then
            echo ""
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "ğŸ§¹ ORPHANED TAG CLEANUP SUMMARY"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "Deleted $CLEANED_COUNT orphaned tag(s):$ORPHANED_TAGS"
            echo "These tags existed in git but their versions were never published to npm."
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          else
            echo "âœ… No orphaned tags found"
          fi

          echo "orphaned-count=$CLEANED_COUNT" >> $GITHUB_OUTPUT
          echo "orphaned-tags=$ORPHANED_TAGS" >> $GITHUB_OUTPUT

      - name: ğŸ” Detect packages to release
        id: detect
        run: |
          SELECTED="${{ inputs.package }}"

          if [ "$SELECTED" = "all-affected" ]; then
            echo "ğŸ” Detecting all affected packages..."
            
            # Find the last release tag to compare against
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            
            if [ -z "$LAST_TAG" ]; then
              echo "âš ï¸ No previous tags found, checking all packages"
              BASE="HEAD~10"
            else
              echo "ğŸ“Œ Comparing against last tag: $LAST_TAG"
              BASE="$LAST_TAG"
            fi
            
            # Get affected projects using Nx
            AFFECTED=$(pnpm nx show projects --affected --base=$BASE --head=HEAD 2>/dev/null || echo "")
            
            # Filter to only publishable packages (in packages/ directory)
            PUBLISHABLE_PACKAGES=""
            for pkg in eslint-devkit eslint-plugin-secure-coding eslint-plugin-crypto eslint-plugin-jwt eslint-plugin-pg eslint-plugin-express-security eslint-plugin-nestjs-security eslint-plugin-browser-security eslint-plugin-lambda-security eslint-plugin-vercel-ai-security eslint-plugin-architecture eslint-plugin-quality eslint-plugin-react-a11y eslint-plugin-react-features eslint-plugin-import-next cli; do
              if echo "$AFFECTED" | grep -q "^$pkg$"; then
                if [ -z "$PUBLISHABLE_PACKAGES" ]; then
                  PUBLISHABLE_PACKAGES="$pkg"
                else
                  PUBLISHABLE_PACKAGES="$PUBLISHABLE_PACKAGES,$pkg"
                fi
              fi
            done
            
            # If eslint-devkit is affected, ensure it's first (dependency order)
            if echo "$PUBLISHABLE_PACKAGES" | grep -q "eslint-devkit"; then
              # Remove devkit from wherever it is
              OTHERS=$(echo "$PUBLISHABLE_PACKAGES" | sed 's/eslint-devkit,//g' | sed 's/,eslint-devkit//g' | sed 's/^eslint-devkit$//g')
              if [ -n "$OTHERS" ]; then
                PUBLISHABLE_PACKAGES="eslint-devkit,$OTHERS"
              else
                PUBLISHABLE_PACKAGES="eslint-devkit"
              fi
            fi
            
            if [ -z "$PUBLISHABLE_PACKAGES" ]; then
              echo "â„¹ï¸ No affected packages found"
              echo "packages=" >> $GITHUB_OUTPUT
              echo "package-count=0" >> $GITHUB_OUTPUT
              echo "matrix={\"package\":[]}" >> $GITHUB_OUTPUT
            else
              echo "ğŸ“¦ Affected packages (in dependency order): $PUBLISHABLE_PACKAGES"
              echo "packages=$PUBLISHABLE_PACKAGES" >> $GITHUB_OUTPUT
              
              # Count packages
              COUNT=$(echo "$PUBLISHABLE_PACKAGES" | tr ',' '\n' | wc -l | tr -d ' ')
              echo "package-count=$COUNT" >> $GITHUB_OUTPUT
              
              # Create matrix JSON (compact, single-line for GitHub Actions)
              MATRIX_JSON=$(echo "$PUBLISHABLE_PACKAGES" | tr ',' '\n' | jq -R . | jq -sc '{package: .}')
              echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT
            fi
          else
            echo "ğŸ“¦ Single package selected: $SELECTED"
            echo "packages=$SELECTED" >> $GITHUB_OUTPUT
            echo "package-count=1" >> $GITHUB_OUTPUT
            echo "matrix={\"package\":[\"$SELECTED\"]}" >> $GITHUB_OUTPUT
          fi

      - name: ğŸ“Š Summary
        run: |
          echo "## ğŸ” Package Detection" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.detect.outputs.package-count }}" = "0" ]; then
            echo "â„¹ï¸ No packages to release" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Package | Status |" >> $GITHUB_STEP_SUMMARY
            echo "|---------|--------|" >> $GITHUB_STEP_SUMMARY
            echo "${{ steps.detect.outputs.packages }}" | tr ',' '\n' | while read pkg; do
              echo "| \`$pkg\` | ğŸš€ Pending |" >> $GITHUB_STEP_SUMMARY
            done
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STEP 2: RELEASE PACKAGES (Sequential to respect dependencies)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  release:
    name: ğŸš€ Release
    needs: detect-affected
    if: needs.detect-affected.outputs.package-count != '0'
    runs-on: ubuntu-latest
    environment: production
    timeout-minutes: 60
    permissions:
      contents: write
      id-token: write

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: âš™ï¸ Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: âš™ï¸ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          registry-url: https://registry.npmjs.org/
          cache: "pnpm"

      - name: ğŸ“¦ Install dependencies
        run: pnpm install --frozen-lockfile

      - name: â¬†ï¸ Upgrade npm for Trusted Publishers
        run: |
          echo "ğŸ“¦ Upgrading npm to 11+ for Trusted Publishers OIDC support..."
          npm install -g npm@latest
          echo "âœ… npm version: $(npm --version)"

      - name: ğŸ—„ï¸ Restore NX cache
        uses: actions/cache@v4
        with:
          path: .nx/cache
          key: nx-cache-${{ runner.os }}-${{ hashFiles('pnpm-lock.yaml') }}-${{ github.sha }}
          restore-keys: |
            nx-cache-${{ runner.os }}-${{ hashFiles('pnpm-lock.yaml') }}-
            nx-cache-${{ runner.os }}-

      - name: ğŸ” Verify NPM Authentication
        if: inputs.dry-run == false
        id: npm-auth
        run: |
          echo "ğŸ” Verifying NPM authentication setup..."
          echo ""

          # For Trusted Publishers, no NPM_TOKEN is needed
          # The OIDC token is minted at publish time by npm
          # NPM_TOKEN is only needed for first-release packages

          HAS_TOKEN=false
          if [ -n "$NPM_TOKEN" ]; then
            HAS_TOKEN=true
            echo "âœ… NPM_TOKEN is configured (will be used for any first-release packages)"
            
            # Try to verify token validity
            AUTH_USER=$(npm whoami --registry=https://registry.npmjs.org/ 2>&1) || {
              echo "âš ï¸ NPM_TOKEN may be invalid (npm whoami failed)"
              echo "   â””â”€ This is OK if all packages use Trusted Publishers"
              echo "   â””â”€ First-release packages will fail without a valid token"
            }
            
            if [ -n "$AUTH_USER" ] && ! echo "$AUTH_USER" | grep -qi "error"; then
              echo "âœ… NPM_TOKEN verified - authenticated as: $AUTH_USER"
              echo "npm-user=$AUTH_USER" >> $GITHUB_OUTPUT
            fi
          else
            echo "â„¹ï¸ No NPM_TOKEN configured"
            echo "   â””â”€ Existing packages: Will use Trusted Publishers (OIDC)"
            echo "   â””â”€ First-release packages: Will FAIL (token required)"
          fi

          echo "has-token=$HAS_TOKEN" >> $GITHUB_OUTPUT
          echo ""
          echo "ğŸ“¦ Publishing will proceed using:"
          echo "   â€¢ Trusted Publishers (OIDC) for existing packages"
          if [ "$HAS_TOKEN" = "true" ]; then
            echo "   â€¢ NPM_TOKEN for first-release packages"
          else
            echo "   â€¢ âš ï¸ NPM_TOKEN NOT available for first-release packages"
          fi
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: ğŸ”§ Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # RELEASE LOOP - Sequential to respect dependencies
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: ğŸš€ Release Packages (Sequential)
        id: release-all
        run: |
          PACKAGES="${{ needs.detect-affected.outputs.packages }}"
          DRY_RUN="${{ inputs.dry-run }}"
          VERSION_SPEC="${{ inputs.version-specifier }}"
          DIST_TAG="${{ inputs.dist-tag }}"
          FORCE_VERSION="${{ inputs.force-version }}"
          GENERATE_CHANGELOG="${{ inputs.generate-changelog }}"
          RUN_CI="${{ inputs.run-ci }}"

          RELEASED_PACKAGES=""
          FAILED_PACKAGES=""
          SKIPPED_PACKAGES=""


          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸš€ RELEASE PIPELINE - Sequential Mode"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ“¦ Packages: $PACKAGES"
          echo "ğŸ“ Version: $VERSION_SPEC"
          echo "ğŸ·ï¸ Dist tag: $DIST_TAG"
          echo "ğŸ” Dry run: $DRY_RUN"
          echo ""

          # Convert comma-separated to array
          IFS=',' read -ra PACKAGE_ARRAY <<< "$PACKAGES"

          for PACKAGE in "${PACKAGE_ARRAY[@]}"; do
            echo ""
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "ğŸ“¦ Processing: $PACKAGE"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            
            # Check if any of this package's dependencies failed (using Nx graph)
            FAILED_DEP=""
            if [ -n "$FAILED_PACKAGES" ]; then
              # Get this package's dependencies from Nx
              DEPS=$(pnpm nx show project $PACKAGE --json 2>/dev/null | jq -r '.implicitDependencies // [] | .[]' 2>/dev/null || echo "")
              # Also check sourceRoot-based dependencies
              DEPS="$DEPS $(pnpm nx graph --print-affected --focus=$PACKAGE 2>/dev/null | jq -r '.nodes | keys[]' 2>/dev/null | grep -v "^$PACKAGE$" || echo "")"
              
              for dep in $DEPS; do
                if echo "$FAILED_PACKAGES" | grep -q "$dep"; then
                  FAILED_DEP="$dep"
                  break
                fi
              done
            fi
            
            if [ -n "$FAILED_DEP" ]; then
              echo "â­ï¸ SKIPPED: $PACKAGE"
              echo "   â””â”€ Reason: Dependency '$FAILED_DEP' failed to release"
              echo "   â””â”€ Action: Fix $FAILED_DEP first, then re-run release"
              SKIPPED_PACKAGES="$SKIPPED_PACKAGES $PACKAGE(dep:$FAILED_DEP)"
              continue
            fi
            
            # Resolve npm package name
            case "$PACKAGE" in
              eslint-devkit)
                NPM_NAME="@interlace/eslint-devkit"
                ;;
              cli)
                NPM_NAME="@interlace/cli"
                ;;
              *)
                NPM_NAME="$PACKAGE"
                ;;
            esac
            
            echo "ğŸ¯ Target project: $PACKAGE"
            echo "ğŸ“› NPM name: $NPM_NAME"
            
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # TAG RECONCILIATION - Deadlock Prevention
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            CURRENT_VERSION=$(node -p "require('./packages/$PACKAGE/package.json').version")
            EXPECTED_TAG="${PACKAGE}@${CURRENT_VERSION}"
            
            echo "ğŸ“Œ Current version: $CURRENT_VERSION"
            echo "ğŸ·ï¸ Expected tag: $EXPECTED_TAG"
            
            # Check for conflicts
            TAG_EXISTS=false
            NPM_EXISTS=false
            
            if git rev-parse "$EXPECTED_TAG" >/dev/null 2>&1; then
              TAG_EXISTS=true
              echo "âš ï¸ Git tag exists: $EXPECTED_TAG"
            fi
            
            if npm view "$NPM_NAME@$CURRENT_VERSION" version >/dev/null 2>&1; then
              NPM_EXISTS=true
              echo "âš ï¸ NPM version exists: $NPM_NAME@$CURRENT_VERSION"
            fi
            
            # Decision matrix for deadlock prevention
            if [ "$TAG_EXISTS" = "true" ] && [ "$NPM_EXISTS" = "true" ]; then
              echo "âœ… Already released - skipping"
              SKIPPED_PACKAGES="$SKIPPED_PACKAGES $PACKAGE"
              continue
            elif [ "$TAG_EXISTS" = "true" ] && [ "$NPM_EXISTS" = "false" ]; then
              echo "âš ï¸ Orphaned tag detected - cleaning up..."
              if [ "$DRY_RUN" = "false" ]; then
                git tag -d "$EXPECTED_TAG" 2>/dev/null || true
                git push origin ":refs/tags/$EXPECTED_TAG" 2>/dev/null || true
                echo "âœ… Orphaned tag cleaned"
              else
                echo "ğŸ” [DRY RUN] Would delete orphaned tag"
              fi
            elif [ "$TAG_EXISTS" = "false" ] && [ "$NPM_EXISTS" = "true" ]; then
              echo "âš ï¸ NPM ahead of git - will bump version"
            fi
            
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # CI VALIDATION (Optional) - Matches ci-pr.yml + lint-pr.yml
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if [ "$RUN_CI" = "true" ]; then
              echo ""
              echo "ğŸ§ª Running CI validation (matches ci-pr.yml + lint-pr.yml)..."
              
              # LINT (matches lint-pr.yml)
              echo "ğŸ“ Linting..."
              pnpm nx lint $PACKAGE  || {
                echo "âŒ FAILED: $PACKAGE"
                echo "   â””â”€ Stage: Lint"
                echo "   â””â”€ Action: Run 'pnpm nx lint $PACKAGE' locally to see errors"
                FAILED_PACKAGES="$FAILED_PACKAGES $PACKAGE"
                continue
              }
              
              # TEST (matches ci-pr.yml)
              echo "ğŸ§ª Testing..."
              pnpm nx test $PACKAGE -c ci  || {
                echo "âŒ FAILED: $PACKAGE"
                echo "   â””â”€ Stage: Test"
                echo "   â””â”€ Action: Run 'pnpm nx test $PACKAGE' locally to see failures"
                FAILED_PACKAGES="$FAILED_PACKAGES $PACKAGE"
                continue
              }
              
              # BUILD (matches ci-pr.yml)
              echo "ğŸ”¨ Building..."
              pnpm nx build $PACKAGE  || {
                echo "âŒ FAILED: $PACKAGE"
                echo "   â””â”€ Stage: Build"
                echo "   â””â”€ Action: Run 'pnpm nx build $PACKAGE' locally to see errors"
                FAILED_PACKAGES="$FAILED_PACKAGES $PACKAGE"
                continue
              }
              
              # TYPECHECK (matches ci-pr.yml)
              echo "ğŸ” Typechecking..."
              pnpm nx typecheck $PACKAGE  || {
                echo "âŒ FAILED: $PACKAGE"
                echo "   â””â”€ Stage: Typecheck"
                echo "   â””â”€ Action: Run 'pnpm nx typecheck $PACKAGE' locally to see errors"
                FAILED_PACKAGES="$FAILED_PACKAGES $PACKAGE"
                continue
              }
              
              echo "âœ… CI validation passed (lint + test + build + typecheck)"
            fi
            
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            # VERSION BUMP
            # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            if [ "$DRY_RUN" = "true" ]; then
              echo ""
              echo "ğŸ” [DRY RUN] Version bump preview:"
              if [ -n "$FORCE_VERSION" ]; then
                pnpm nx release version $FORCE_VERSION --projects=$PACKAGE --dry-run || true
              elif [ "$VERSION_SPEC" != "auto" ]; then
                pnpm nx release version $VERSION_SPEC --projects=$PACKAGE --dry-run || true
              else
                pnpm nx release version --projects=$PACKAGE --dry-run || true
              fi
            else
              echo ""
              echo "ğŸ“ Bumping version..."
              
              VERSION_FAILED=false
              if [ -n "$FORCE_VERSION" ]; then
                pnpm nx release version $FORCE_VERSION --projects=$PACKAGE || VERSION_FAILED=true
              elif [ "$VERSION_SPEC" != "auto" ]; then
                pnpm nx release version $VERSION_SPEC --projects=$PACKAGE || VERSION_FAILED=true
              else
                OUTPUT=$(pnpm nx release version --projects=$PACKAGE 2>&1) || VERSION_FAILED=true
                echo "$OUTPUT"
                
                # Fallback to patch if no conventional commits or no changes
                if [ "$VERSION_FAILED" = "true" ] && echo "$OUTPUT" | grep -qiE "(No changes detected|No projects are set to be processed|nothing to commit)"; then
                  echo "â„¹ï¸ No conventional commits detected, falling back to patch..."
                  pnpm nx release version patch --projects=$PACKAGE || {
                    echo "âŒ FAILED: $PACKAGE"
                    echo "   â””â”€ Stage: Version bump (patch fallback)"
                    echo "   â””â”€ Action: Check nx release configuration - is $PACKAGE in nx.json release.projects?"
                    FAILED_PACKAGES="$FAILED_PACKAGES $PACKAGE"
                    continue
                  }
                  VERSION_FAILED=false
                fi
              fi
              
              if [ "$VERSION_FAILED" = "true" ]; then
                echo "âŒ FAILED: $PACKAGE"
                echo "   â””â”€ Stage: Version bump"
                echo "   â””â”€ Action: Run 'pnpm nx release version --projects=$PACKAGE' locally"
                FAILED_PACKAGES="$FAILED_PACKAGES $PACKAGE"
                continue
              fi
              
              NEW_VERSION=$(node -p "require('./packages/$PACKAGE/package.json').version")
              echo "âœ… New version: $NEW_VERSION"
              
              # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              # TEST + BUILD (Always required - build depends on test)
              # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              echo ""
              echo "ğŸ§ª Testing package..."
              pnpm nx test $PACKAGE -c ci  || {
                echo "âŒ FAILED: $PACKAGE"
                echo "   â””â”€ Stage: Test (pre-publish)"
                echo "   â””â”€ Action: Run 'pnpm nx test $PACKAGE' locally to see failures"
                FAILED_PACKAGES="$FAILED_PACKAGES $PACKAGE"
                continue
              }
              
              echo ""
              echo "ğŸ”¨ Building package..."
              pnpm nx build $PACKAGE  || {
                echo "âŒ FAILED: $PACKAGE"
                echo "   â””â”€ Stage: Build (pre-publish)"
                echo "   â””â”€ Action: Run 'pnpm nx build $PACKAGE' locally to see errors"
                FAILED_PACKAGES="$FAILED_PACKAGES $PACKAGE"
                continue
              }
              
              # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              # CHANGELOG
              # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              if [ "$GENERATE_CHANGELOG" = "true" ]; then
                echo ""
                echo "ğŸ“ Generating changelog..."
                pnpm nx release changelog --projects=$PACKAGE || echo "âš ï¸ Changelog failed (non-blocking)"
              fi
              
              # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              # PUSH (Git is source of truth - push BEFORE npm)
              # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              echo ""
              echo "ğŸ“¤ Pushing changes to git..."
              
              # Pull latest to avoid push conflicts
              git pull --rebase origin main || {
                echo "âŒ FAILED: $PACKAGE"
                echo "   â””â”€ Stage: Git pull --rebase"
                echo "   â””â”€ Cause: Merge conflict or upstream changes"
                echo "   â””â”€ Action: Pull latest changes locally and resolve conflicts"
                FAILED_PACKAGES="$FAILED_PACKAGES $PACKAGE"
                continue
              }
              
              git push origin main || {
                echo "âŒ FAILED: $PACKAGE"
                echo "   â””â”€ Stage: Git push"
                echo "   â””â”€ Cause: Push rejected (race condition or permission issue)"
                echo "   â””â”€ Action: Re-run the release workflow"
                FAILED_PACKAGES="$FAILED_PACKAGES $PACKAGE"
                continue
              }
              
              git push origin --tags || echo "âš ï¸ Some tags may already exist"
              echo "âœ… Git push successful"
              
              # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              # PUBLISH TO NPM (with First-Release + Trusted Publishers support)
              # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              echo ""
              echo "ğŸ“¤ Publishing to NPM..."
              
              # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              # STEP 1: Detect if this is a first-release (package doesn't exist on npm)
              # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              IS_FIRST_RELEASE=false
              PACKAGE_EXISTS_CHECK=$(npm view "$NPM_NAME" name 2>&1) || true
              
              if echo "$PACKAGE_EXISTS_CHECK" | grep -qiE "(404|not found|no such package)"; then
                IS_FIRST_RELEASE=true
                echo "ğŸ†• First release detected - package '$NPM_NAME' does not exist on npm yet"
                echo "   â””â”€ Will use --first-release flag"
                echo "   â””â”€ After success: Configure Trusted Publishers at npmjs.com"
              fi
              
              # Pre-publish check: version already exists?
              if [ "$IS_FIRST_RELEASE" = "false" ]; then
                if npm view "$NPM_NAME@$NEW_VERSION" version >/dev/null 2>&1; then
                  echo "âš ï¸ Version $NEW_VERSION already on npm - skipping publish"
                  SKIPPED_PACKAGES="$SKIPPED_PACKAGES $PACKAGE"
                  continue
                fi
              fi
              
              # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              # STEP 2: Build publish command with appropriate flags
              # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              PUBLISH_CMD="pnpm nx release publish --projects=$PACKAGE --tag $DIST_TAG"
              
              if [ "$IS_FIRST_RELEASE" = "true" ]; then
                PUBLISH_CMD="$PUBLISH_CMD --first-release"
                echo "ğŸ“¦ Command: $PUBLISH_CMD"
              fi
              
              # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              # STEP 3: Execute publish with comprehensive error handling
              # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
              PUBLISH_OUTPUT=$($PUBLISH_CMD 2>&1) || {
                PUBLISH_EXIT=$?
                echo "$PUBLISH_OUTPUT"
                echo ""
                
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # ACTIONABLE ERROR DIAGNOSIS
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                
                # ERROR: Version already exists (403/EPUBLISHCONFLICT)
                if echo "$PUBLISH_OUTPUT" | grep -qiE "(403|EPUBLISHCONFLICT|cannot publish over|already exists)"; then
                  echo "âš ï¸ Version $NEW_VERSION already on npm (detected during publish) - marking as skipped"
                  SKIPPED_PACKAGES="$SKIPPED_PACKAGES $PACKAGE"
                  continue
                fi
                
                # ERROR: 401 Unauthorized
                if echo "$PUBLISH_OUTPUT" | grep -qiE "(401|unauthorized|ENEEDAUTH|not logged in)"; then
                  echo "âŒ NPM 401: Auth credentials invalid/expired for $NPM_NAME"
                  echo "   â””â”€ Fix: Configure Trusted Publishers at npmjs.com or update NPM_TOKEN"
                  FAILED_PACKAGES="$FAILED_PACKAGES $PACKAGE"
                  continue
                fi
                
                # ERROR: 403 Forbidden (not version conflict)
                if echo "$PUBLISH_OUTPUT" | grep -qiE "(403|forbidden|EPERM)" && ! echo "$PUBLISH_OUTPUT" | grep -qiE "(already exists|cannot publish over)"; then
                  echo "âŒ NPM 403: Token lacks permission for $NPM_NAME"
                  echo "   â””â”€ Fix: Verify Trusted Publishers config (repo: ofri-peretz/eslint, workflow: release.yml)"
                  FAILED_PACKAGES="$FAILED_PACKAGES $PACKAGE"
                  continue
                fi
                
                # ERROR: 404 Not Found (for updates to non-existent package)
                if echo "$PUBLISH_OUTPUT" | grep -qiE "(404|not found)" && [ "$IS_FIRST_RELEASE" = "false" ]; then
                  echo "âŒ NPM 404: Package $NPM_NAME not found - may be first release"
                  echo "   â””â”€ Fix: Re-run workflow - it should detect --first-release"
                  FAILED_PACKAGES="$FAILED_PACKAGES $PACKAGE"
                  continue
                fi
                
                # ERROR: Network/Registry issues
                if echo "$PUBLISH_OUTPUT" | grep -qiE "(ECONNREFUSED|ETIMEDOUT|ENOTFOUND|network|registry)"; then
                  echo "âŒ NPM Network Error: Cannot reach registry for $NPM_NAME"
                  echo "   â””â”€ Fix: Wait and re-run. Check https://status.npmjs.org/"
                  FAILED_PACKAGES="$FAILED_PACKAGES $PACKAGE"
                  continue
                fi
                
                # GENERIC ERROR: Unknown failure
                echo "âŒ NPM Publish Failed for $NPM_NAME (exit $PUBLISH_EXIT)"
                echo "   â””â”€ Fix: Try 'pnpm nx release publish --projects=$PACKAGE --dry-run' locally"
                FAILED_PACKAGES="$FAILED_PACKAGES $PACKAGE"
                continue
              }
              
              echo "$PUBLISH_OUTPUT"
              echo "âœ… Published $NPM_NAME@$NEW_VERSION"
              
              # First-release post-publish guidance
              if [ "$IS_FIRST_RELEASE" = "true" ]; then
                echo "ğŸ‰ First release success! Configure Trusted Publishers: npmjs.com â†’ $NPM_NAME â†’ Settings â†’ Publishing access â†’ Add GitHub Actions (repo: ofri-peretz/eslint, workflow: release.yml)"
              fi
              
              RELEASED_PACKAGES="$RELEASED_PACKAGES $PACKAGE@$NEW_VERSION"
            fi
          done

          # Output results
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ“Š RELEASE SUMMARY"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "âœ… Released: $RELEASED_PACKAGES"
          echo "â­ï¸ Skipped: $SKIPPED_PACKAGES"
          echo "âŒ Failed: $FAILED_PACKAGES"

          echo "released=$RELEASED_PACKAGES" >> $GITHUB_OUTPUT
          echo "skipped=$SKIPPED_PACKAGES" >> $GITHUB_OUTPUT
          echo "failed=$FAILED_PACKAGES" >> $GITHUB_OUTPUT

          # Fail workflow if any packages failed
          if [ -n "$FAILED_PACKAGES" ]; then
            echo "âŒ Some packages failed to release"
            exit 1
          fi
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          NPM_CONFIG_PROVENANCE: true
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NX_SKIP_NX_CLOUD: "true"

      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # SUMMARY
      # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: ğŸ“Š Generate Summary
        if: always()
        run: |
          echo "## ğŸ“¦ Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ inputs.dry-run }}" = "true" ]; then
            echo "### ğŸ” Dry Run Mode" >> $GITHUB_STEP_SUMMARY
            echo "No changes were made." >> $GITHUB_STEP_SUMMARY
          else
            RELEASED="${{ steps.release-all.outputs.released }}"
            SKIPPED="${{ steps.release-all.outputs.skipped }}"
            FAILED="${{ steps.release-all.outputs.failed }}"
            
            if [ -n "$RELEASED" ]; then
              echo "### âœ… Released" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              for pkg in $RELEASED; do
                echo "- \`$pkg\`" >> $GITHUB_STEP_SUMMARY
              done
            fi
            
            if [ -n "$SKIPPED" ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "### â­ï¸ Skipped (already released)" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              for pkg in $SKIPPED; do
                echo "- \`$pkg\`" >> $GITHUB_STEP_SUMMARY
              done
            fi
            
            if [ -n "$FAILED" ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "### âŒ Failed" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              for pkg in $FAILED; do
                echo "- \`$pkg\`" >> $GITHUB_STEP_SUMMARY
              done
            fi
          fi
