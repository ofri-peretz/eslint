/**
 * ESLint Rule: no-toctou-vulnerability
 * Detects Time-of-Check-Time-of-Use vulnerabilities
 * CWE-367: Time-of-check Time-of-use (TOCTOU) Race Condition
 * 
 * @see https://cwe.mitre.org/data/definitions/367.html
 * @see https://owasp.org/www-community/vulnerabilities/TOCTOU_Race_Condition
 */
import type { TSESLint, TSESTree } from '@interlace/eslint-devkit';
import { formatLLMMessage, MessageIcons } from '@interlace/eslint-devkit';
import { createRule } from '@interlace/eslint-devkit';

type MessageIds =
  | 'toctouVulnerability'
  | 'useAtomicOperations'
  | 'useFsPromises'
  | 'addProperLocking';

export interface Options {
  /** Ignore in test files. Default: true */
  ignoreInTests?: boolean;
  
  /** File system methods to check. Default: ['fs.existsSync', 'fs.statSync', 'fs.accessSync'] */
  fsMethods?: string[];
}

type RuleOptions = [Options?];

export const noToctouVulnerability = createRule<RuleOptions, MessageIds>({
  name: 'no-toctou-vulnerability',
  meta: {
    type: 'problem',
    docs: {
      description: 'Detects Time-of-Check-Time-of-Use vulnerabilities',
    },
    hasSuggestions: true,
    messages: {
      toctouVulnerability: formatLLMMessage({
        icon: MessageIcons.SECURITY,
        issueName: 'TOCTOU vulnerability',
        cwe: 'CWE-367',
        description: 'Time-of-check Time-of-use race condition detected',
        severity: 'HIGH',
        fix: 'Use atomic operations or fs.promises for file operations',
        documentationLink: 'https://cwe.mitre.org/data/definitions/367.html',
      }),
      useAtomicOperations: formatLLMMessage({
        icon: MessageIcons.INFO,
        issueName: 'Use Atomic Operations',
        description: 'Use atomic file operations',
        severity: 'LOW',
        fix: 'fs.promises.access() then fs.promises.readFile()',
        documentationLink: 'https://nodejs.org/api/fs.html#fspromisesaccesspath-mode',
      }),
      useFsPromises: formatLLMMessage({
        icon: MessageIcons.INFO,
        issueName: 'Use fs.promises',
        description: 'Use fs.promises API',
        severity: 'LOW',
        fix: 'await fs.promises.readFile() instead of sync operations',
        documentationLink: 'https://nodejs.org/api/fs.html#promises-api',
      }),
      addProperLocking: formatLLMMessage({
        icon: MessageIcons.INFO,
        issueName: 'Add File Locking',
        description: 'Add proper locking mechanism',
        severity: 'LOW',
        fix: 'Use proper-lockfile or similar for concurrent access',
        documentationLink: 'https://github.com/moxystudio/node-proper-lockfile',
      }),
    },
    schema: [
      {
        type: 'object',
        properties: {
          ignoreInTests: {
            type: 'boolean',
            default: true,
          },
          fsMethods: {
            type: 'array',
            items: { type: 'string' },
            default: ['fs.existsSync', 'fs.statSync', 'fs.accessSync'],
          },
        },
        additionalProperties: false,
      },
    ],
  },
  defaultOptions: [
    {
      ignoreInTests: true,
      fsMethods: ['fs.existsSync', 'fs.statSync', 'fs.accessSync'],
    },
  ],
  create(context: TSESLint.RuleContext<MessageIds, RuleOptions>, [options = {}]) {
    const {
ignoreInTests = true 
}: Options = options || {};

    const filename = context.getFilename();
    const isTestFile = ignoreInTests && /\.(test|spec)\.(ts|tsx|js|jsx)$/.test(filename);

    if (isTestFile) {
      return {};
    }

    const sourceCode = context.sourceCode || context.sourceCode;

    /**
     * Check for TOCTOU patterns
     */
    function checkCallExpression(node: TSESTree.CallExpression) {
      // 1. Identify the file operation (Use)
      let useMethodName = '';
      if (node.callee.type === 'MemberExpression' && node.callee.property.type === 'Identifier') {
        const objectName = node.callee.object.type === 'Identifier' ? node.callee.object.name : '';
        if (objectName === 'fs' || objectName === 'fsPromises') {
           useMethodName = node.callee.property.name;
        }
      } else if (node.callee.type === 'Identifier') {
        useMethodName = node.callee.name;
      }

      const riskyUseMethods = ['readFileSync', 'writeFileSync', 'readFile', 'writeFile', 'openSync', 'open', 'unlinkSync', 'unlink'];
      if (!riskyUseMethods.includes(useMethodName)) {
        return;
      }

      const useArg = node.arguments[0];
      if (!useArg) return;

      // 2. Walk up to find the condition (Check)
      let current: TSESTree.Node | undefined = node.parent;
      while (current) {
        if (current.type === 'IfStatement') {
          // Extract the condition node
          let condition = current.test;
          
          // Handle negated condition: if (!exists(path)) { create(path) } -> also TOCTOU but different logic? 
          // Actually TOCTOU is usually Check(exists) -> Use(read).
          // If (!exists) -> create is Check -> Use.
          // But strict TOCTOU is checking state then acting.
          
          // If checking for negation
          if (condition.type === 'UnaryExpression' && condition.operator === '!') {
             condition = condition.argument;
          }

          if (condition.type === 'CallExpression') {
             // Check if it's a file check method
             let checkMethodName = '';
             if (condition.callee.type === 'MemberExpression' && condition.callee.property.type === 'Identifier') {
                checkMethodName = condition.callee.property.name;
             } else if (condition.callee.type === 'Identifier') {
                checkMethodName = condition.callee.name;
             }

             const checkMethods = ['existsSync', 'statSync', 'accessSync', 'exists', 'stat', 'access'];
             if (checkMethods.includes(checkMethodName)) {
                
                // Compare arguments
                const checkArg = condition.arguments[0];
                if (checkArg) {
                    // Method 1: Identifier match (same variable)
                    if (checkArg.type === 'Identifier' && useArg.type === 'Identifier' && checkArg.name === useArg.name) {
                        reportToctou(node);
                        return;
                    }

                    // Method 2: Text match (fallback)
                    const checkArgText = sourceCode.getText(checkArg).replace(/\s/g, '');
                    const useArgText = sourceCode.getText(useArg).replace(/\s/g, '');
                    if (checkArgText === useArgText) {
                        reportToctou(node);
                        return;
                    }
                }
             }

             // Handle stats.isFile() / stats.isDirectory() pattern
             if (condition.callee.type === 'MemberExpression' && 
                 condition.callee.property.type === 'Identifier' &&
                 ['isFile', 'isDirectory'].includes(condition.callee.property.name) &&
                 condition.callee.object.type === 'Identifier') {
                 
                 const statsVarName = condition.callee.object.name;
                 let currentScope = sourceCode.getScope(condition);
                 let variable = null;
                 
                 while (currentScope) {
                     variable = currentScope.variables.find(v => v.name === statsVarName);
                     if (variable) break;
                     currentScope = currentScope.upper;
                 }
                 
                 if (variable && variable.defs.length > 0) {
                     const def = variable.defs[0];
                     if (def.type === 'Variable' && def.node.init && def.node.init.type === 'CallExpression') {
                         const init = def.node.init;
                         if (init.callee.type === 'MemberExpression' &&
                             init.callee.property.type === 'Identifier' &&
                             ['statSync', 'lstatSync', 'stat', 'lstat'].includes(init.callee.property.name)) {
                                 
                                 const statArg = init.arguments[0];
                                 if (statArg) {
                                     const checkArgText = sourceCode.getText(statArg).replace(/\s/g, '');
                                     const useArgText = sourceCode.getText(useArg).replace(/\s/g, '');
                                     if (checkArgText === useArgText) {
                                         reportToctou(node);
                                         return;
                                     }
                                 }
                         }
                     }
                 }
             }
          }
        }
        current = current.parent as TSESTree.Node;
      }
    }

    function reportToctou(node: TSESTree.Node) {
       context.report({
        node,
        messageId: 'toctouVulnerability',
        suggest: [
          {
            messageId: 'useAtomicOperations',
            fix: () => null,
          },
          {
            messageId: 'useFsPromises',
            fix: () => null,
          },
          {
            messageId: 'addProperLocking',
            fix: () => null,
          },
        ],
      });
    }

    return {
      CallExpression: checkCallExpression,
    };
  },
});

