---
title: no-unsafe-query
description: Prevents NoSQL injection by detecting direct use of user input in MongoDB query objects.
---

> **Keywords:** NoSQL injection, CWE-943, MongoDB, Mongoose, operator injection, query manipulation, security

Prevents NoSQL injection by detecting direct use of user input in MongoDB query objects.

âš ï¸ This rule **errors** by default in the `recommended` config.

## Quick Summary

| Aspect            | Details                                   |
| ----------------- | ----------------------------------------- |
| **CWE Reference** | CWE-943 (NoSQL Injection)                 |
| **OWASP**         | A03:2021 - Injection                      |
| **Severity**      | Critical (CVSS: 9.8)                      |
| **Category**      | Security                                  |
| **ESLint MCP**    | âœ… Optimized for AI assistant integration |

## Rule Details

NoSQL injection allows attackers to bypass authentication or extract data by manipulating query operators. Unlike SQL injection which uses strings, NoSQL injection exploits the ability to pass objects with operators like `$ne`, `$gt`, `$or`.

### Attack Example

```typescript
// Attacker sends: { "password": { "$ne": null } }
// This becomes: { email: "victim@test.com", password: { $ne: null } }
// Which matches ANY user with that email, bypassing password check!
```

### âŒ Incorrect

```typescript
// Direct req.body in query - allows operator injection
User.find({ email: req.body.email });

// Direct req.query in query
db.collection('users').findOne({ username: req.query.user });

// Direct req.params in query
User.updateOne({ _id: req.params.id }, { $set: { active: true } });
```

### âœ… Correct

```typescript
// Wrap with $eq operator - forces value comparison
User.find({ email: { $eq: req.body.email } });

// Cast to string to prevent object injection
db.collection('users').findOne({ username: { $eq: String(req.query.user) } });

// Use ObjectId constructor for ID fields
User.updateOne(
  { _id: new ObjectId(req.params.id) },
  { $set: { active: true } },
);

// Use schema validation + sanitization
const email = sanitize(req.body.email);
User.find({ email: { $eq: email } });
```

## Error Message Format

```
ðŸ”’ CWE-943 OWASP:A03:2021-Injection CVSS:9.8 | NoSQL injection via user input | CRITICAL
   Fix: Wrap user input with explicit $eq operator: { field: { $eq: sanitize(value) } }
```

## Options

```json
{
  "rules": {
    "mongodb-security/no-unsafe-query": [
      "error",
      {
        "allowInTests": true,
        "additionalMethods": ["customFind"]
      }
    ]
  }
}
```

| Option              | Type       | Default | Description                             |
| ------------------- | ---------- | ------- | --------------------------------------- |
| `allowInTests`      | `boolean`  | `true`  | Skip detection in `.test.ts`/`.spec.ts` |
| `additionalMethods` | `string[]` | `[]`    | Additional method names to check        |

## Known False Positives

These patterns are safe but may be flagged:

### Variables Not From User Input

```typescript
// FP: Variable from database/config, not user input
const adminEmail = config.adminEmail; // Hardcoded or from config
User.find({ email: adminEmail }); // â† May flag but is safe
```

**Workaround**: Use `$eq` pattern consistently, or add to `allowPatterns`.

### Sanitized Input Without $eq

```typescript
// FP: Input is sanitized but not wrapped in $eq
const safeEmail = sanitize(req.body.email);
User.find({ email: safeEmail }); // â† May flag
```

**Workaround**: Always use `{ $eq: value }` pattern.

## Known False Negatives

The following patterns are **not detected** due to static analysis limitations:

### Dynamic Query Building

**Why**: Query built programmatically cannot be traced.

```typescript
// âŒ NOT DETECTED
const query = {};
query[field] = req.body.value; // Dynamic property
User.find(query);
```

### Spread Operator Injection

**Why**: Spread operators merge objects at runtime.

```typescript
// âŒ NOT DETECTED
User.find({ ...baseQuery, ...req.body }); // Entire body spread into query
```

### Indirect Variable Assignment

**Why**: Multi-step variable flow isn't tracked.

```typescript
// âŒ NOT DETECTED
let query = { email: 'safe@test.com' };
query = { email: req.body.email }; // Reassignment not tracked
User.find(query);
```

### Function Parameter Passthrough

**Why**: Values passed through functions aren't traced.

```typescript
// âŒ NOT DETECTED
function findByEmail(email) {
  return User.find({ email }); // Can't determine source of 'email'
}
findByEmail(req.body.email);
```

### Aggregation Pipeline

**Why**: Complex pipeline stages aren't analyzed.

```typescript
// âŒ NOT DETECTED
User.aggregate([
  { $match: { email: req.body.email } }, // Variable in pipeline
]);
```

> **Recommendation**: Always validate/sanitize user input AND use `$eq` wrapper. Defense in depth!

## When Not To Use It

- When using ODM schema validation that prevents object injection
- In migration files with static queries
- When all input passes through strict validation layer
- In test files (use `allowInTests: true`)

## Related Rules

- [no-operator-injection](./no-operator-injection.md) - Detects $ne, $gt, $or injection specifically
- [no-unsafe-where](./no-unsafe-where.md) - Prevents $where operator RCE
- [require-schema-validation](./require-schema-validation.md) - Requires Mongoose validators

## References

- [OWASP Testing for NoSQL Injection](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05.6-Testing_for_NoSQL_Injection)
- [CWE-943: Improper Neutralization of Special Elements in Data Query Logic](https://cwe.mitre.org/data/definitions/943.html)
- [MongoDB Security Checklist](https://www.mongodb.com/docs/manual/administration/security-checklist/)
