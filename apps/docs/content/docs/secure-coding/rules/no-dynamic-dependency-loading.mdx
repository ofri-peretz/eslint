---
title: no-dynamic-dependency-loading
description: Prevents runtime dependency injection with dynamic paths
---

> Prevents runtime dependency injection with dynamic paths

**Severity:** üü† HIGH  
**CWE:** [CWE-1104: Use of Unmaintained Third Party Components](https://cwe.mitre.org/data/definitions/1104.html)  
**OWASP Mobile:** [M2: Inadequate Supply Chain Security](https://owasp.org/www-project-mobile-top-10/)

## Rule Details

This rule detects dynamically constructed paths in `require()` and `import()` statements. Dynamic dependency loading bypasses static analysis and package lock integrity checks, enabling dependency confusion and supply chain attacks.

### Why This Matters

Dynamic imports create security vulnerabilities:

- **Dependency confusion**: Attackers publish malicious packages with similar names
- **Supply chain attacks**: Runtime code injection through compromised dynamic imports
- **No integrity checks**: Dynamic paths bypass lock file validation
- **Code execution**: Attackers can execute arbitrary code by controlling the import path

## ‚ùå Incorrect

```typescript
// Dynamic require() with variable
const moduleName = req.query.module; // User-controlled!
const plugin = require(moduleName); // ‚ùå Code injection vulnerability

// Dynamic import() with template literal
const feature = userInput;
const module = await import(`./${feature}/index.js`); // ‚ùå Path traversal risk

// Dynamic require() from config
const config = JSON.parse(fs.readFileSync('config.json'));
const handler = require(config.handlerPath); // ‚ùå Config-based injection

// Conditional dynamic import
const libName = process.env.USE_ALT_LIB ? 'alt-lib' : 'main-lib';
const lib = require(libName); // ‚ùå Environment-controlled dependency
```

## ‚úÖ Correct

```typescript
// Static imports (preferred)
import express from 'express'; // ‚úÖ Static, lock file verified
import { Router } from './router'; // ‚úÖ Static relative import

// Static require()
const fs = require('fs'); // ‚úÖ Static

// Plugin system with allow list
const ALLOWED_PLUGINS = ['auth', 'logging', 'metrics'] as const;
type AllowedPlugin = (typeof ALLOWED_PLUGINS)[number];

function loadPlugin(name: string) {
  if (!ALLOWED_PLUGINS.includes(name as AllowedPlugin)) {
    throw new Error(`Plugin ${name} not in allow list`);
  }

  // Static switch instead of dynamic require
  switch (name) {
    case 'auth':
      return require('./plugins/auth'); // ‚úÖ Static path
    case 'logging':
      return require('./plugins/logging'); // ‚úÖ Static path
    case 'metrics':
      return require('./plugins/metrics'); // ‚úÖ Static path
    default:
      throw new Error('Invalid plugin');
  }
}

// Code splitting with static imports
async function loadFeature(feature: 'admin' | 'user') {
  if (feature === 'admin') {
    return import('./features/admin'); // ‚úÖ Static path
  } else {
    return import('./features/user'); // ‚úÖ Static path
  }
}
```

## Known False Negatives

The following patterns are **not detected** due to static analysis limitations:

### Nested Dynamic Imports

**Why**: We only detect top-level dynamic `require()` and `import()`. Nested or indirect dynamic imports are not traced.

```typescript
// ‚ùå NOT DETECTED - Indirect dynamic import
function loader(path: string) {
  return import(path); // Dynamic import hidden in function
}
loader(userInput);
```

**Mitigation**: Review all code paths that load dependencies. Enforce static imports via code review.

### Eval-based Loading

**Why**: `eval()` and `Function()` constructor can dynamically load code, but are not import-specific.

```typescript
// ‚ùå NOT DETECTED - Eval-based loading
eval(`const lib = require('${userInput}')`); // Use detect-eval-with-expression rule
```

**Mitigation**: Enable `detect-eval-with-expression` rule. Never use `eval()` for imports.

### Native Module Loading

**Way**: Native Node.js `Module` API dynamic loading is not detected.

```typescript
// ‚ùå NOT DETECTED - Module._load
const Module = require('module');
Module._load(dynamicPath); // Low-level dynamic loading
```

**Mitigation**: Avoid `Module._load` and other low-level APIs. Use static imports only.

## ‚öôÔ∏è Configuration

This rule has no configuration options. It flags all non-literal arguments to `require()` and all non-literal `import()` sources.

## üîó Related Rules

- [`require-dependency-integrity`](./require-dependency-integrity.md) - SRI for CDN resources
- [`require-package-lock`](./require-package-lock.md) - Enforce lock files
- [`detect-suspicious-dependencies`](./detect-suspicious-dependencies.md) - Dependency confusion

## üìö References

- [CWE-1104: Unmaintained Third Party Components](https://cwe.mitre.org/data/definitions/1104.html)
- [OWASP Mobile M2: Inadequate Supply Chain Security](https://owasp.org/www-project-mobile-top-10/)
- [Dependency Confusion Attack](https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610)
- [npm Security Best Practices](https://docs.npmjs.com/security-best-practices)
