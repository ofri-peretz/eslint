/**
 * GitHub Content API Route
 * 
 * Unified endpoint for fetching content from GitHub with caching.
 * Supports .md, .mdx, .json files with type-aware caching TTLs.
 * 
 * ALL-REMOTE Policy: Content updates in GitHub are reflected
 * automatically without redeploying the docs site.
 */

import { NextResponse } from 'next/server';
import { getTTLForPath } from '@/lib/json-cache';

// GitHub configuration
const GITHUB_OWNER = process.env.GITHUB_OWNER || 'ofri-peretz';
const GITHUB_REPO = process.env.GITHUB_REPO || 'eslint';
const GITHUB_BRANCH = process.env.GITHUB_BRANCH || 'main';

// Content type configurations
const CONTENT_TYPES = {
  'md': { mimeType: 'text/markdown', defaultTTL: 3600 },
  'mdx': { mimeType: 'text/markdown', defaultTTL: 3600 },
  'json': { mimeType: 'application/json', defaultTTL: 3600 },
  'txt': { mimeType: 'text/plain', defaultTTL: 3600 },
} as const;

// Common content paths in the monorepo
const CONTENT_PATHS = {
  // Rule documentation
  rules: 'packages/{plugin}/docs/rules',
  // Plugin READMEs
  readme: 'packages/{plugin}/README.md',
  // Changelogs
  changelog: 'packages/{plugin}/CHANGELOG.md',
  // Plugin metadata
  meta: 'packages/{plugin}/src/index.ts',
  // Rule metadata JSON (generated by GH Actions)
  rulesMeta: 'generated/rules/{plugin}.json',
  // Coverage data (generated by GH Actions)
  coverage: 'generated/coverage.json',
  // Plugin stats (generated by GH Actions)
  stats: 'generated/plugin-stats.json',
} as const;

interface GitHubContentResponse {
  success: boolean;
  data?: {
    content: string | object;
    path: string;
    encoding: 'utf-8' | 'base64';
    sha?: string;
    size?: number;
  };
  meta?: {
    source: string;
    ttl: number;
    fetchedAt: string;
    contentType: string;
  };
  error?: string;
}

/**
 * Fetch raw content from GitHub
 */
async function fetchGitHubContent(
  path: string,
  options?: { parseJson?: boolean }
): Promise<GitHubContentResponse> {
  const url = `https://raw.githubusercontent.com/${GITHUB_OWNER}/${GITHUB_REPO}/${GITHUB_BRANCH}/${path}`;
  const extension = path.split('.').pop() || 'txt';
  const contentType = CONTENT_TYPES[extension as keyof typeof CONTENT_TYPES] || CONTENT_TYPES.txt;
  const ttl = getTTLForPath(path);
  
  try {
    const response = await fetch(url, {
      next: { revalidate: ttl },
      headers: {
        'Accept': contentType.mimeType,
        'User-Agent': 'Interlace-Docs-Fetcher/1.0',
      },
    });
    
    if (!response.ok) {
      if (response.status === 404) {
        return {
          success: false,
          error: `Content not found: ${path}`,
        };
      }
      throw new Error(`GitHub fetch failed: ${response.status}`);
    }
    
    const text = await response.text();
    let content: string | object = text;
    
    // Parse JSON if requested or if it's a .json file
    if (options?.parseJson || extension === 'json') {
      try {
        content = JSON.parse(text);
      } catch {
        // Keep as string if JSON parsing fails
      }
    }
    
    return {
      success: true,
      data: {
        content,
        path,
        encoding: 'utf-8',
      },
      meta: {
        source: 'github',
        ttl,
        fetchedAt: new Date().toISOString(),
        contentType: contentType.mimeType,
      },
    };
  } catch (error) {
    console.error(`[GitHub Content] Failed to fetch ${path}:`, error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

/**
 * Resolve template paths like 'packages/{plugin}/README.md'
 */
function resolvePath(template: string, params: Record<string, string>): string {
  let path = template;
  for (const [key, value] of Object.entries(params)) {
    path = path.replace(`{${key}}`, value);
  }
  return path;
}

/**
 * GET /api/github
 * 
 * Query params:
 * - path: Direct path to file (e.g., "packages/eslint-plugin-jwt/README.md")
 * - type: Content type shortcut (readme, changelog, rules, meta, coverage, stats)
 * - plugin: Plugin name for templated paths
 * - rule: Rule name for rule documentation
 * - json: If "true", parse JSON content
 */
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  
  // Get parameters
  const directPath = searchParams.get('path');
  const contentType = searchParams.get('type');
  const plugin = searchParams.get('plugin');
  const rule = searchParams.get('rule');
  const parseJson = searchParams.get('json') === 'true';
  
  let targetPath: string;
  
  // Determine the path to fetch
  if (directPath) {
    // Direct path takes precedence
    targetPath = directPath;
  } else if (contentType && CONTENT_PATHS[contentType as keyof typeof CONTENT_PATHS]) {
    // Use template path
    const template = CONTENT_PATHS[contentType as keyof typeof CONTENT_PATHS];
    
    if (template.includes('{plugin}') && !plugin) {
      return NextResponse.json(
        { success: false, error: 'Plugin parameter required for this content type' },
        { status: 400 }
      );
    }
    
    targetPath = resolvePath(template, { 
      plugin: plugin || '',
      rule: rule || '',
    });
    
    // Handle rules path specially
    if (contentType === 'rules' && rule) {
      targetPath = `${targetPath}/${rule}.md`;
    }
  } else {
    return NextResponse.json(
      { 
        success: false, 
        error: 'Either path or type parameter is required',
        availableTypes: Object.keys(CONTENT_PATHS),
      },
      { status: 400 }
    );
  }
  
  // Fetch the content
  const result = await fetchGitHubContent(targetPath, { parseJson });
  
  if (!result.success) {
    return NextResponse.json(result, { status: 404 });
  }
  
  return NextResponse.json(result);
}

/**
 * POST /api/github/batch
 * 
 * Fetch multiple files in a single request
 * Body: { paths: string[] }
 */
export async function POST(request: Request) {
  try {
    const body = await request.json();
    const paths = body.paths as string[];
    
    if (!Array.isArray(paths) || paths.length === 0) {
      return NextResponse.json(
        { success: false, error: 'paths array is required' },
        { status: 400 }
      );
    }
    
    if (paths.length > 20) {
      return NextResponse.json(
        { success: false, error: 'Maximum 20 paths per request' },
        { status: 400 }
      );
    }
    
    const results = await Promise.all(
      paths.map(path => fetchGitHubContent(path))
    );
    
    return NextResponse.json({
      success: true,
      data: results,
      meta: {
        fetchedAt: new Date().toISOString(),
        count: results.filter(r => r.success).length,
        total: paths.length,
      },
    });
  } catch (error) {
    return NextResponse.json(
      { success: false, error: 'Invalid request body' },
      { status: 400 }
    );
  }
}
